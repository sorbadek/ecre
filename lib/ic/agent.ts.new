import { HttpAgent, Actor, type Identity, type ActorSubclass } from "@dfinity/agent"
import type { IDL } from "@dfinity/candid"
import { AuthClient } from "@dfinity/auth-client"
import { idlFactory } from "@/lib/ic/learning-analytics.idl"

// Configuration
export const HOST = "http://127.0.0.1:4943" // Local replica

// Canister IDs
export const LEARNING_ANALYTICS_CANISTER_ID = "bkyz2-fmaaa-aaaaa-qaaaq-cai"
export const NOTIFICATIONS_CANISTER_ID = "bd3sg-teaaa-aaaaa-qaaba-cai"
export const RECOMMENDATIONS_CANISTER_ID = "be2us-64aaa-aaaaa-qaabq-cai"
export const SESSIONS_CANISTER_ID = "br5f7-7uaaa-aaaaa-qaaca-cai"
export const SOCIAL_CANISTER_ID = "bw4dl-smaaa-aaaaa-qaacq-cai"
export const USER_PROFILE_CANISTER_ID = "b77ix-eeaaa-aaaaa-qaada-cai"
export const CANDID_UI_CANISTER_ID = "by6od-j4aaa-aaaaa-qaadq-cai"

export const LOCAL_CANDID_UI = `http://127.0.0.1:4943/?canisterId=${CANDID_UI_CANISTER_ID}&id=`

export const CANISTER_IDS = {
  LEARNING_ANALYTICS: LEARNING_ANALYTICS_CANISTER_ID,
  NOTIFICATIONS: NOTIFICATIONS_CANISTER_ID,
  RECOMMENDATIONS: RECOMMENDATIONS_CANISTER_ID,
  SESSIONS: SESSIONS_CANISTER_ID,
  SOCIAL: SOCIAL_CANISTER_ID,
  USER_PROFILE: USER_PROFILE_CANISTER_ID,
  CANDID_UI: CANDID_UI_CANISTER_ID
}

// Shared agent instance
let sharedAgent: HttpAgent | null = null
let currentIdentity: Identity | null = null
let authClientInstance: AuthClient | null = null

// Timeout for API calls (in milliseconds)
const API_TIMEOUT = 10000

// Auth configuration
export const AUTH_CONFIG = {
  // 24 hours in nanoseconds
  maxTimeToLive: BigInt(24 * 60 * 60 * 1000 * 1000 * 1000),
  // 5 minutes in nanoseconds
  idleOptions: {
    idleTimeout: 5 * 60 * 1000, // 5 minutes in milliseconds
    disableDefaultIdleCallback: true,
  },
}

// Custom fetch with CBOR and CORS support
export const customFetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
  // Create URL object from input
  const requestUrl = new URL(input.toString())
  
  // Check if this is a local development environment
  const isLocal = typeof window !== 'undefined' && 
    (window.location.hostname === 'localhost' || 
     window.location.hostname === '127.0.0.1');
  
  // For local development with IC API calls, ensure we're using the right host and protocol
  if (isLocal) {
    const localReplicaUrl = new URL('http://127.0.0.1:4943');
    requestUrl.protocol = localReplicaUrl.protocol;
    requestUrl.hostname = localReplicaUrl.hostname;
    requestUrl.port = localReplicaUrl.port;
    
    // Add no-cache headers for IC API calls
    requestUrl.searchParams.set('_', Date.now().toString());
  }
  
  // Create new headers object
  const headers = new Headers(init?.headers);
  
  // Set default headers
  if (!headers.has('Content-Type')) {
    headers.set('Content-Type', 'application/cbor');
  }
  if (!headers.has('Accept')) {
    headers.set('Accept', 'application/cbor');
  }
  
  // For local development, handle CORS and other headers
  const requestInit: RequestInit = {
    ...init,
    headers,
    mode: 'cors',
    credentials: 'omit',
  };
  
  if (isLocal) {
    // Add CORS headers for local development
    if (typeof window !== 'undefined') {
      headers.set('Origin', window.location.origin);
    }
    headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    headers.set('Access-Control-Allow-Credentials', 'true');
  }
  
  try {
    // Make the fetch request
    const response = await fetch(requestUrl.toString(), requestInit);
    
    // Check for CORS errors
    if (!response.ok && response.type === 'opaque') {
      throw new Error(`CORS error or network error occurred: ${response.status} ${response.statusText}`);
    }
    
    return response;
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;
  }
};

// Initialize AuthClient
export const initAuthClient = async (): Promise<AuthClient> => {
  if (!authClientInstance) {
    authClientInstance = await AuthClient.create({
      idleOptions: AUTH_CONFIG.idleOptions,
    });
  }
  return authClientInstance;
};

// Get or create an agent
export const getAgent = async (identity?: Identity): Promise<HttpAgent> => {
  if (sharedAgent && !identity) {
    return sharedAgent;
  }

  // Create a new agent
  const agent = new HttpAgent({
    host: HOST,
    fetch: customFetch,
  });

  // Only fetch the root key in development
  if (process.env.NODE_ENV !== 'production') {
    try {
      await agent.fetchRootKey();
    } catch (error) {
      console.warn('Failed to fetch root key. Make sure the IC is running locally.');
      throw error;
    }
  }

  if (identity) {
    agent.replaceIdentity(identity);
  }

  if (!identity) {
    sharedAgent = agent;
  }

  return agent;
};

// Clear the cached agent and identity
export const clearAgentCache = () => {
  sharedAgent = null;
  currentIdentity = null;
  authClientInstance = null;
};

// Create an actor with the given identity
export const createActor = async <T>({
  canisterId,
  idlFactory,
  identity,
}: {
  canisterId: string
  idlFactory: IDL.InterfaceFactory
  identity?: Identity
}): Promise<ActorSubclass<T>> => {
  const agent = await getAgent(identity);
  
  return Actor.createActor(idlFactory, {
    agent,
    canisterId,
  });
};

// Create an authenticated actor for the learning analytics canister
export const createLearningAnalyticsActor = async (identity?: Identity) => {
  return createActor({
    canisterId: LEARNING_ANALYTICS_CANISTER_ID,
    idlFactory: idlFactory,
    identity,
  });
};

// Helper to handle API calls with timeout
export const withTimeout = async <T>(
  promise: Promise<T>,
  timeout = API_TIMEOUT
): Promise<T> => {
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => {
      reject(new Error(`Request timed out after ${timeout}ms`));
    }, timeout);
  });

  return Promise.race([promise, timeoutPromise]);
};

// Check if the user is authenticated
export const isAuthenticated = async (): Promise<boolean> => {
  const authClient = await initAuthClient();
  return await authClient.isAuthenticated();
};

// Get the current identity
export const getIdentity = async (): Promise<Identity | null> => {
  const authClient = await initAuthClient();
  
  if (currentIdentity) {
    return currentIdentity;
  }
  
  if (await authClient.isAuthenticated()) {
    currentIdentity = authClient.getIdentity();
    return currentIdentity;
  }
  
  return null;
};

// Login function
export const login = async (): Promise<Identity | null> => {
  const authClient = await initAuthClient();
  
  return new Promise((resolve) => {
    authClient.login({
      ...AUTH_CONFIG,
      onSuccess: () => {
        const identity = authClient.getIdentity();
        currentIdentity = identity;
        resolve(identity);
      },
      onError: (error) => {
        console.error('Login error:', error);
        resolve(null);
      },
    });
  });
};

// Logout function
export const logout = async () => {
  const authClient = await initAuthClient();
  await authClient.logout();
  clearAgentCache();
};

// Default export for backward compatibility
export default {
  getAgent,
  createActor,
  createLearningAnalyticsActor,
  withTimeout,
  isAuthenticated,
  getIdentity,
  login,
  logout,
  clearAgentCache,
  HOST,
  CANISTER_IDS,
};
