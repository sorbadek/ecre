"use client"

import React, { useEffect, useRef, useState, useCallback, useMemo } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { toast } from 'sonner';
import {
  Mic,
  MicOff,
  Video as VideoIcon,
  VideoOff,
  Monitor,
  MonitorOff,
  MessageSquare,
  Users,
  Settings,
  Maximize,
  Minimize,
  PhoneOff,
  Play,
  Square,
  Clock,
  User,
  Calendar,
} from 'lucide-react';
import { Session } from '@/lib/session-client';
import { useApiClients } from '@/lib/use-api-clients';
import { getJibrilRecorder, JibrilRecordingConfig } from '@/lib/jibril-recorder';

// Define RecordingInfo interface locally since it's not exported from session-client
interface RecordingInfo {
  id: string;
  sessionId: string;
  status: 'recording' | 'stopped' | 'processing' | 'ready';
  startTime: bigint;
  endTime?: bigint;
  duration?: number;
  url?: string;
  size?: bigint;
}

// Jitsi Meet API types
declare global {
  interface Window {
    JitsiMeetExternalAPI: any;
  }
}

interface JitsiMeetProps {
  session: Session;
  onLeave?: () => Promise<void>;
  onSessionEnd?: () => void;
  onRecordingStart?: (recordingInfo: RecordingInfo) => void;
  onRecordingStop?: (recordingInfo: RecordingInfo) => void;
  onParticipantJoined?: (participant: any) => void;
  onParticipantLeft?: (participant: any) => void;
}

interface JitsiParticipant {
  id: string;
  displayName: string;
  email?: string;
  avatarURL?: string;
  role: 'moderator' | 'participant';
}

const JitsiMeet: React.FC<JitsiMeetProps> = ({
  session,
  onLeave,
  onSessionEnd,
  onRecordingStart,
  onRecordingStop,
  onParticipantJoined,
  onParticipantLeft,
}) => {
  // Refs
  const jitsiContainerRef = useRef<HTMLDivElement>(null);
  const jitsiApiRef = useRef<any>(null);
  
  // State
  const [isJitsiLoaded, setIsJitsiLoaded] = useState(false);
  const [isConnected, setIsConnected] = useState(false);
  const [participants, setParticipants] = useState<JitsiParticipant[]>([]);
  const [isRecording, setIsRecording] = useState(false);
  const [recordingDuration, setRecordingDuration] = useState(0);
  const [currentRecording, setCurrentRecording] = useState<RecordingInfo | null>(null);
  const [jwtToken, setJwtToken] = useState<string | null>(null);
  
  // Hooks
  const { isAuthenticated, sessionClient, user } = useApiClients();
  const jibrilRecorder = getJibrilRecorder();

  // Extract Jitsi config from session with fallbacks
  const jitsiConfig = useMemo(() => {
    // 1. Try to get from direct jitsiConfig array
    if (session.jitsiConfig?.[0]) {
      return session.jitsiConfig[0];
    }
    
    // 2. Try to get from metadata
    if ((session as any).metadata?.jitsiConfig) {
      return (session as any).metadata.jitsiConfig;
    }
    
    // 3. Try to extract from description
    const extractFromDescription = (description: string) => {
      const jitsiConfigMatch = description.match(/<!-- JITSI_CONFIG:(.+?)-->/s);
      if (jitsiConfigMatch?.[1]) {
        try {
          return JSON.parse(jitsiConfigMatch[1]);
        } catch (error) {
          console.error('Failed to parse Jitsi config from description:', error);
        }
      }
      return null;
    };
    
    const extracted = session.description ? extractFromDescription(session.description) : null;
    if (extracted) return extracted;
    
    // 4. Return default config if nothing else works
    return {
      roomName: `peer-${Date.now()}`,
      displayName: user?.principal?.toString() || 'Anonymous',
      email: '',
      avatarUrl: '',
      moderator: false,
      startWithAudioMuted: false,
      startWithVideoMuted: false,
      enableRecording: false,
      enableScreenSharing: true,
      enableChat: true,
      maxParticipants: 20,
    };
  }, [session, user?.principal]);

  // Audio/Video controls state
  const [isAudioMuted, setIsAudioMuted] = useState(jitsiConfig.startWithAudioMuted || false);
  const [isVideoMuted, setIsVideoMuted] = useState(jitsiConfig.startWithVideoMuted || false);
  const [isScreenSharing, setIsScreenSharing] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isChatOpen, setIsChatOpen] = useState(jitsiConfig.enableChat || false);

  // Get user info for Jitsi
  const getUserInfo = useCallback(() => ({
    displayName: user?.principal?.toString() || 'Anonymous',
    email: user?.email || '',
    avatar: user?.avatarUrl || '',
  }), [user]);

  // Load Jitsi Meet API
  useEffect(() => {
    const loadJitsiScript = () => {
      if (window.JitsiMeetExternalAPI) {
        setIsJitsiLoaded(true);
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://meet.jit.si/external_api.js';
      script.async = true;
      script.onload = () => setIsJitsiLoaded(true);
      script.onerror = () => {
        toast.error('Failed to load Jitsi Meet. Please check your internet connection.');
      };
      document.head.appendChild(script);
    };

    loadJitsiScript();
  }, []);

  // Initialize Jitsi when loaded and container is ready
  useEffect(() => {
    if (!isJitsiLoaded || !jitsiContainerRef.current) return;

    try {
      const userInfo = getUserInfo();
      
      // Initialize Jitsi Meet
      const api = new window.JitsiMeetExternalAPI('meet.jit.si', {
        roomName: jitsiConfig.roomName,
        width: '100%',
        height: '100%',
        parentNode: jitsiContainerRef.current,
        userInfo: {
          displayName: userInfo.displayName,
          email: userInfo.email,
        },
        configOverwrite: {
          startWithAudioMuted: jitsiConfig.startWithAudioMuted,
          startWithVideoMuted: jitsiConfig.startWithVideoMuted,
          enableWelcomePage: false,
          enableClosePage: false,
          enableNoAudioDetection: true,
          enableNoisyMicDetection: true,
          enableAutomaticUrlCopy: true,
          enableEncodedTransformSupport: true,
          disableDeepLinking: true,
          disableInviteFunctions: true,
          disableRemoteMute: !jitsiConfig.moderator,
          disableRemoteControl: !jitsiConfig.moderator,
          enableEmailInStats: false,
          enableLobbyChat: jitsiConfig.enableChat,
          enableWelcomePage: false,
          prejoinPageEnabled: false,
          startAudioMuted: jitsiConfig.startWithAudioMuted ? 1 : 0,
          startVideoMuted: jitsiConfig.startWithVideoMuted ? 1 : 0,
        },
        interfaceConfigOverwrite: {
          SHOW_JITSI_WATERMARK: false,
          SHOW_WATERMARK_FOR_GUESTS: false,
          SHOW_BRAND_WATERMARK: false,
          SHOW_POWERED_BY: false,
          DISABLE_JOIN_LEAVE_NOTIFICATIONS: true,
          DISABLE_VIDEO_BACKGROUND: true,
          DISABLE_PRESENCE_STATUS: true,
          DISABLE_DOMINANT_SPEAKER_INDICATOR: false,
          DISABLE_TRANSCRIPTION_SUBTITLES: true,
          DISABLE_POLLS: true,
          DISABLE_REACTIONS: true,
          DISABLE_MEETING_NAME: false,
          DISABLE_JOIN_LEAVE_NOTIFICATIONS: true,
          MOBILE_APP_PROMO: false,
          MAXIMUM_ZOOMING_COEFFICIENT: 1.0,
          ENABLE_FEEDBACK_ANIMATION: false,
          CLOSE_PAGE_GUEST_HINT: false,
          RECENT_LIST_ENABLED: false,
          DEFAULT_BACKGROUND: '#111827',
          DEFAULT_LOGO_URL: '',
          HIDE_INVITE_MORE_HEADER: true,
          TOOLBAR_BUTTONS: [
            'microphone', 'camera', 'closedcaptions', 'desktop', 'fullscreen',
            'fodeviceselection', 'hangup', 'profile', 'chat', 'recording',
            'livestreaming', 'etherpad', 'sharedvideo', 'settings', 'raisehand',
            'videoquality', 'filmstrip', 'feedback', 'stats', 'shortcuts',
            'tileview', 'videobackgroundblur', 'download', 'help', 'mute-everyone',
            'security'
          ],
        },
      });

      jitsiApiRef.current = api;

      // Event listeners
      api.addListener('videoConferenceJoined', handleConferenceJoined);
      api.addListener('videoConferenceLeft', handleConferenceLeft);
      api.addListener('participantJoined', handleParticipantJoined);
      api.addListener('participantLeft', handleParticipantLeft);
      api.addListener('audioMuteStatusChanged', handleAudioMuteStatusChanged);
      api.addListener('videoMuteStatusChanged', handleVideoMuteStatusChanged);
      api.addListener('screenSharingStatusChanged', handleScreenSharingStatusChanged);
      api.addListener('recordingStatusChanged', handleRecordingStatusChanged);

      // Cleanup function
      return () => {
        api.dispose();
        jitsiApiRef.current = null;
      };
    } catch (error) {
      console.error('Error initializing Jitsi Meet:', error);
      toast.error('Failed to initialize Jitsi Meet. Please try again.');
    }
  }, [isJitsiLoaded, jitsiConfig, getUserInfo]);

  // Recording timer
  useEffect(() => {
    let interval: NodeJS.Timeout;
    
    if (isRecording && currentRecording) {
      interval = setInterval(() => {
        const now = Date.now() * 1_000_000; // Convert to nanoseconds
        const startTime = Number(currentRecording.startTime);
        const duration = Math.floor((now - startTime) / 1_000_000_000); // Convert to seconds
        setRecordingDuration(duration);
      }, 1000);
    }

    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [isRecording, currentRecording]);

  // Event handlers
  const handleConferenceJoined = useCallback((event: any) => {
    console.log('Conference joined:', event);
    setIsConnected(true);
    toast.success('Successfully joined the session');
  }, []);

  const handleConferenceLeft = useCallback((event: any) => {
    console.log('Conference left:', event);
    setIsConnected(false);
    onSessionEnd?.();
  }, [onSessionEnd]);

  const handleParticipantJoined = useCallback((event: any) => {
    console.log('Participant joined:', event);
    const participant: JitsiParticipant = {
      id: event.id,
      displayName: event.displayName || 'Anonymous',
      email: event.email,
      avatarURL: event.avatarURL,
      role: event.role || 'participant',
    };
    
    setParticipants(prev => [...prev, participant]);
    onParticipantJoined?.(participant);
    toast.info(`${participant.displayName} joined the session`);
  }, [onParticipantJoined]);

  const handleParticipantLeft = useCallback((event: any) => {
    console.log('Participant left:', event);
    setParticipants(prev => prev.filter(p => p.id !== event.id));
    onParticipantLeft?.(event);
    toast.info(`${event.displayName || 'A participant'} left the session`);
  }, [onParticipantLeft]);

  const handleAudioMuteStatusChanged = useCallback((event: any) => {
    setIsAudioMuted(event.muted);
  }, []);

  const handleVideoMuteStatusChanged = useCallback((event: any) => {
    setIsVideoMuted(event.muted);
  }, []);

  const handleScreenSharingStatusChanged = useCallback((event: any) => {
    setIsScreenSharing(event.on);
  }, []);

  const handleRecordingStatusChanged = useCallback((event: any) => {
    console.log('Recording status changed:', event);
    if (event.status === 'on') {
      setIsRecording(true);
    } else if (event.status === 'off') {
      setIsRecording(false);
    }
  }, []);

  // Control handlers
  const toggleAudio = useCallback(() => {
    if (!jitsiApiRef.current) return;
    jitsiApiRef.current.executeCommand('toggleAudio');
  }, []);

  const toggleVideo = useCallback(() => {
    if (!jitsiApiRef.current) return;
    jitsiApiRef.current.executeCommand('toggleVideo');
  }, []);

  const toggleScreenShare = useCallback(() => {
    if (!jitsiApiRef.current) return;
    jitsiApiRef.current.executeCommand('toggleShareScreen');
  }, []);

  const toggleFullscreen = useCallback(() => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => {
        console.error('Error attempting to enable fullscreen:', err);
      });
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
    setIsFullscreen(!isFullscreen);
  }, [isFullscreen]);

  const toggleChat = useCallback(() => {
    if (!jitsiApiRef.current) return;
    jitsiApiRef.current.executeCommand('toggleChat');
    setIsChatOpen(!isChatOpen);
  }, [isChatOpen]);

  const leaveSession = useCallback(async () => {
    try {
      if (jitsiApiRef.current) {
        jitsiApiRef.current.dispose();
        jitsiApiRef.current = null;
      }
      
      if (onLeave) {
        await onLeave();
      }
    } catch (error) {
      console.error('Error leaving session:', error);
      toast.error('Failed to leave session properly');
    }
  }, [onLeave]);

  const startRecording = useCallback(async () => {
    if (!session.isRecordingEnabled) {
      toast.error('Recording is not enabled for this session');
      return;
    }

    try {
      const recordingConfig: JibrilRecordingConfig = {
        quality: '1080p',
        format: 'mp4',
        includeAudio: true,
        includeVideo: true,
        includeScreenShare: false,
        bitrate: 2500000, // 2.5 Mbps
        frameRate: 30,
      };

      // Start real Jibril recording
      const jibrilRecordingId = await jibrilRecorder.startRecording({
        ...recordingConfig,
        roomName: jitsiConfig.roomName,
      });

      const recordingInfo: RecordingInfo = {
        id: jibrilRecordingId,
        sessionId: session.id,
        status: 'recording',
        startTime: BigInt(Date.now() * 1_000_000), // Convert to nanoseconds
      };

      setCurrentRecording(recordingInfo);
      setIsRecording(true);
      setRecordingDuration(0);
      onRecordingStart?.(recordingInfo);
      toast.success('Recording started successfully!');
    } catch (error) {
      console.error('Error starting recording:', error);
      toast.error('Failed to start recording: ' + (error as Error).message);
    }
  }, [jitsiConfig.roomName, jibrilRecorder, onRecordingStart, session.id, session.isRecordingEnabled]);

  const stopRecording = useCallback(async () => {
    if (!currentRecording) return;

    try {
      // Stop Jibril recording
      await jibrilRecorder.stopRecording(currentRecording.id);
      
      const updatedRecording: RecordingInfo = {
        ...currentRecording,
        status: 'processing',
        endTime: BigInt(Date.now() * 1_000_000), // Convert to nanoseconds
      };
      
      setCurrentRecording(updatedRecording);
      setIsRecording(false);
      onRecordingStop?.(updatedRecording);
      toast.success('Recording stopped. Processing...');
    } catch (error) {
      console.error('Error stopping recording:', error);
      toast.error('Failed to stop recording: ' + (error as Error).message);
    }
  }, [currentRecording, jibrilRecorder, onRecordingStop]);

  // Format recording duration to HH:MM:SS
  const formatRecordingDuration = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // Render loading state
  if (!isJitsiLoaded) {
    return (
      <Card className="w-full h-96 flex items-center justify-center">
        <CardContent>
          <div className="flex flex-col items-center space-y-4">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
            <p className="text-muted-foreground">Loading Jitsi Meet...</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  // Render main component
  return (
    <div className="flex flex-col w-full h-full bg-background rounded-lg overflow-hidden border">
      {/* Main content area */}
      <div className="flex-1 relative">
        {/* Jitsi container */}
        <div 
          ref={jitsiContainerRef} 
          className="w-full h-full bg-gray-900"
        />
        
        {/* Top bar with session info */}
        <div className="absolute top-4 left-4 right-4 flex justify-between items-center">
          <div className="bg-black/70 text-white px-3 py-1 rounded-full flex items-center space-x-2">
            <Users className="h-4 w-4" />
            <span>{participants.length + 1} participants</span>
          </div>
          
          {isRecording && (
            <div className="bg-red-600 text-white px-3 py-1 rounded-full flex items-center space-x-2">
              <div className="w-2 h-2 bg-white rounded-full animate-pulse"></div>
              <span>REC {formatRecordingDuration(recordingDuration)}</span>
            </div>
          )}
        </div>
        
        {/* Bottom controls */}
        <div className="absolute bottom-4 left-0 right-0 flex justify-center">
          <div className="bg-black/70 backdrop-blur-sm rounded-full px-4 py-2 flex items-center space-x-2">
            <Button
              variant={isAudioMuted ? "destructive" : "secondary"}
              size="icon"
              onClick={toggleAudio}
              className="rounded-full"
            >
              {isAudioMuted ? <MicOff className="h-5 w-5" /> : <Mic className="h-5 w-5" />}
            </Button>
            
            <Button
              variant={isVideoMuted ? "destructive" : "secondary"}
              size="icon"
              onClick={toggleVideo}
              className="rounded-full"
            >
              {isVideoMuted ? <VideoOff className="h-5 w-5" /> : <VideoIcon className="h-5 w-5" />}
            </Button>
            
            <Button
              variant={isScreenSharing ? "default" : "secondary"}
              size="icon"
              onClick={toggleScreenShare}
              className="rounded-full"
              disabled={!jitsiConfig.enableScreenSharing}
            >
              {isScreenSharing ? <MonitorOff className="h-5 w-5" /> : <Monitor className="h-5 w-5" />}
            </Button>
            
            <Button
              variant={isChatOpen ? "default" : "secondary"}
              size="icon"
              onClick={toggleChat}
              className="rounded-full"
              disabled={!jitsiConfig.enableChat}
            >
              <MessageSquare className="h-5 w-5" />
            </Button>
            
            <Separator orientation="vertical" className="h-6 mx-1" />
            
            {jitsiConfig.enableRecording && (
              <Button
                variant={isRecording ? "destructive" : "secondary"}
                size="sm"
                onClick={isRecording ? stopRecording : startRecording}
                className="rounded-full flex items-center space-x-1"
                disabled={!isConnected}
              >
                {isRecording ? (
                  <>
                    <Square className="h-4 w-4" />
                    <span>Stop Recording</span>
                  </>
                ) : (
                  <>
                    <Play className="h-4 w-4" />
                    <span>Record</span>
                  </>
                )}
              </Button>
            )}
            
            <Button
              variant="secondary"
              size="icon"
              onClick={toggleFullscreen}
              className="rounded-full ml-1"
            >
              {isFullscreen ? (
                <Minimize className="h-5 w-5" />
              ) : (
                <Maximize className="h-5 w-5" />
              )}
            </Button>
            
            <Button
              variant="destructive"
              size="sm"
              onClick={leaveSession}
              className="rounded-full ml-1"
            >
              <PhoneOff className="h-4 w-4 mr-1" />
              <span>Leave</span>
            </Button>
          </div>
        </div>
      </div>
      
      {/* Session info bar */}
      <div className="bg-card border-t p-2 flex items-center justify-between text-sm">
        <div className="flex items-center space-x-2">
          <User className="h-4 w-4 text-muted-foreground" />
          <span className="font-medium">{jitsiConfig.displayName}</span>
          <span className="text-muted-foreground">is in the session</span>
        </div>
        
        <div className="flex items-center space-x-4">
          <div className="flex items-center space-x-1 text-muted-foreground">
            <Clock className="h-4 w-4" />
            <span>{new Date().toLocaleTimeString()}</span>
          </div>
          
          <div className="flex items-center space-x-1 text-muted-foreground">
            <Calendar className="h-4 w-4" />
            <span>{new Date().toLocaleDateString()}</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default JitsiMeet;
